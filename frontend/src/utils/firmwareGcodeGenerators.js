/**
 * Firmware-specific G-code Generators
 * Handles differences between GRBL, Marlin, and Smoothieware
 */

export const firmwareCommands = {
  grbl: {
    name: 'GRBL',
    position: '?',
    home: '$H',
    unlock: '$X',
    reset: '\x18', // Ctrl+X
    feedHold: '!',
    resume: '~',
    statusQuery: '?',
    positionFormat: 'grbl' // <Idle|MPos:x,y,z>
  },
  marlin: {
    name: 'Marlin',
    position: 'M114',
    home: 'G28',
    unlock: 'M999',
    reset: 'M112',
    feedHold: 'M0',
    resume: 'M108',
    statusQuery: 'M114',
    positionFormat: 'marlin' // X:x Y:y Z:z
  },
  smoothie: {
    name: 'Smoothieware',
    position: '?',
    home: '$H',
    unlock: '$X',
    reset: 'reset',
    feedHold: '!',
    resume: '~',
    statusQuery: '?',
    positionFormat: 'grbl' // <Idle|MPos:x,y,z>
  }
}

/**
 * Generate firmware-specific preamble
 */
export function generatePreamble(firmware, machineType) {
  const commands = []

  if (firmware === 'marlin') {
    // Marlin-specific initialization
    commands.push('G21 ; Set units to millimeters')
    commands.push('G90 ; Absolute positioning')
    if (machineType === 'cnc_printer') {
      commands.push('M82 ; Absolute extrusion mode')
    }
  } else if (firmware === 'grbl' || firmware === 'smoothie') {
    // GRBL/Smoothie initialization
    commands.push('G21 ; Set units to millimeters')
    commands.push('G90 ; Absolute positioning')
  }

  return commands.join('\n')
}

/**
 * Generate firmware-specific postamble
 */
export function generatePostamble(firmware, machineType) {
  const commands = []

  if (firmware === 'marlin') {
    if (machineType === 'cnc_printer') {
      commands.push('M104 S0 ; Turn off extruder')
      commands.push('M140 S0 ; Turn off bed')
    }
    commands.push('G91 ; Relative positioning')
    commands.push('G1 Z10 F300 ; Raise Z')
    commands.push('G90 ; Absolute positioning')
    commands.push('G28 X0 Y0 ; Home X and Y')
    commands.push('M84 ; Disable steppers')
  } else if (firmware === 'grbl' || firmware === 'smoothie') {
    commands.push('G0 Z10 ; Raise Z')
    commands.push('G0 X0 Y0 ; Return to home')
  }

  return commands.join('\n')
}

/**
 * Generate movement command based on firmware
 */
export function generateMovement(firmware, x, y, z, feedRate, isTravel = false) {
  let command = isTravel ? 'G0' : 'G1'

  if (firmware === 'marlin') {
    // Marlin prefers explicit feed rates
    command += ` X${x.toFixed(3)} Y${y.toFixed(3)}`
    if (z !== undefined && z !== null) {
      command += ` Z${z.toFixed(3)}`
    }
    if (!isTravel && feedRate) {
      command += ` F${feedRate}`
    }
  } else {
    // GRBL/Smoothie
    command += ` X${x.toFixed(3)} Y${y.toFixed(3)}`
    if (z !== undefined && z !== null) {
      command += ` Z${z.toFixed(3)}`
    }
    if (feedRate) {
      command += ` F${feedRate}`
    }
  }

  return command
}

/**
 * Generate laser/spindle control based on firmware
 */
export function generateLaserControl(firmware, power, isOn) {
  if (firmware === 'marlin') {
    // Marlin uses M106/M107 for laser (fan PWM) or M3/M5 for spindle
    if (isOn) {
      return `M3 S${power} ; Laser/Spindle on`
    } else {
      return 'M5 ; Laser/Spindle off'
    }
  } else if (firmware === 'grbl') {
    // GRBL uses spindle commands
    if (isOn) {
      return `M3 S${power}`
    } else {
      return 'M5'
    }
  } else if (firmware === 'smoothie') {
    // Smoothieware uses spindle or laser module
    if (isOn) {
      return `M3 S${power}`
    } else {
      return 'M5'
    }
  }

  return ''
}

/**
 * Generate home command
 */
export function generateHomeCommand(firmware) {
  return firmwareCommands[firmware]?.home || 'G28'
}

/**
 * Generate position query command
 */
export function generatePositionQuery(firmware) {
  return firmwareCommands[firmware]?.position || '?'
}

/**
 * Get recommended baud rate for firmware
 */
export function getRecommendedBaudRate(firmware) {
  const rates = {
    grbl: 115200,
    marlin: 250000,
    smoothie: 115200
  }
  return rates[firmware] || 115200
}

/**
 * Export complete G-code with firmware-specific formatting
 */
export function exportGcode(shapes, profile) {
  const firmware = profile.firmwareType || 'grbl'
  const machineType = profile.machineType || 'laser_engraver'

  const lines = []

  // Header
  lines.push('; Generated by Mechanicus CAD')
  lines.push(`; Firmware: ${firmwareCommands[firmware].name}`)
  lines.push(`; Machine Type: ${machineType}`)
  lines.push('; ' + new Date().toISOString())
  lines.push('')

  // Preamble
  lines.push('; === PREAMBLE ===')
  lines.push(generatePreamble(firmware, machineType))
  lines.push('')

  // Custom preamble from profile
  if (profile.preamble) {
    lines.push(profile.preamble)
  }

  // Shapes
  lines.push('; === SHAPES ===')
  shapes.forEach((shape, index) => {
    lines.push(`; Shape ${index + 1}`)

    // Shape preamble
    if (profile.shapePreamble) {
      lines.push(profile.shapePreamble)
    }

    // Move to start (travel move, laser off)
    const start = shape[0]
    lines.push(generateMovement(firmware, start.x, start.y, profile.zTravel, profile.travelSpeed, true))

    // Turn laser ON once at the beginning of shape
    const laserPower = profile.laserPower || 1000
    lines.push(generateLaserControl(firmware, laserPower, true))

    // Draw entire shape with laser on (continuous movement)
    const pathCommands = []
    shape.forEach((point, i) => {
      if (i === 0) return // Skip first point (already moved there)

      const z = profile.zDraw || 0
      pathCommands.push(generateMovement(firmware, point.x, point.y, z, profile.drawSpeed, false))
    })

    // Add path commands with position queries at intervals
    const POSITION_QUERY_INTERVAL = 10 // Query position every 10 commands
    const positionQueryCmd = firmware === 'grbl' ? '?' : 'M114'

    pathCommands.forEach((cmd, index) => {
      lines.push(cmd)

      // Insert position query every N commands (but not on last command)
      if ((index + 1) % POSITION_QUERY_INTERVAL === 0 &&
          index < pathCommands.length - 1) {
        lines.push(positionQueryCmd)
      }
    })

    // Turn laser OFF once at the end of shape
    lines.push(generateLaserControl(firmware, laserPower, false))

    // Lift at end
    const end = shape[shape.length - 1]
    lines.push(generateMovement(firmware, end.x, end.y, profile.zLift, profile.travelSpeed, true))

    // Shape postamble
    if (profile.shapePostamble) {
      lines.push(profile.shapePostamble)
    }

    lines.push('')
  })

  // Postamble
  lines.push('; === POSTAMBLE ===')
  if (profile.postamble) {
    lines.push(profile.postamble)
  }
  lines.push(generatePostamble(firmware, machineType))

  return lines.join('\n')
}